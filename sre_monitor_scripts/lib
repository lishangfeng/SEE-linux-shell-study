#! /bin/bash

__errmsg() {
	  echo "$*" >&2
}

function report_falcon() {
    local metric=$1
    local value=$2
    local step=$3
    local endpoint=`hostname -a`
    local ts=$(date +%s)
    local tags=$4
    local counterType="GAUGE"
    local url="http://transfer.falcon.vip.sankuai.com:6060/api/push"

    if [ -n "$o_debug" ] && [ "$o_debug" -gt 0 ]; then
        set -- cat
    else
        set -- curl -s -X POST -d @- "$url"
    fi
    cat <<-EOF | "$@" | python -m json.tool
[
  {
    "counterType": "$counterType",
    "endpoint": "$endpoint",
    "metric": "$metric",
    "step": $step,
    "tags": "$tags",
    "timestamp": $ts,
    "value": $value
  }
]
EOF
}

function report_falcon_common() {
    local metric="$1"; shift
    local value="$1"; shift
    local tags="$1"; shift
    local step="${1:-60}"; shift

    report_falcon "$metric" "$value" "$step" "$tags"
}

function report_log_error_num() {
    local service_name="$1"
    local log_file="$2"
    local process_name="$3"
    local error_pattern="$4"
    local date_format="${5:-'%Y-%m-%d %H:%M'}"
    local ignore_pattern="${6:-''}"
    local metric="${7:-}"
    

    local tags="service=$service_name"
    if [ -z "$metric" ]; then
        local metric="$service_name.log.error"
    fi
    local step=60
    local time_pattern="`date +"$date_format" -d'1 minutes ago'`"
    local result=0

    if [ -f $log_file ]; then
        if [ -z "$ignore_pattern" ]; then
            result=`grep -a -E "$time_pattern"  "$log_file" | grep -a -E "$error_pattern" | wc -l`
        else
            result=`grep -a -E "$time_pattern"  "$log_file" | grep -a -E "$error_pattern" | grep -v -E "$ignore_pattern" | wc -l`
        fi
    elif [ `ps aux | grep $process_name | wc -l` -gt 1 ]; then
        result=-1
        __errmsg "进程${process_name}存在但是日志${log_file}不存在，可能是日志路径更改造成"
    else
        result=9999
    fi
    if [ $result -ne 9999 ]; then
        report_falcon $metric $result $step $tags
    fi
}

function get_pattern_log_num() {
    local pattern="$1"
    local logfile="$2"
    local result=0

    if [ -f "$logfile" ]; then
        result=`grep -E "$pattern" "$logfile" | wc -l`
    else
        result=-1
        __errmsg "没有找到日志文件${logfile}"
    fi
    echo $result
}

function process_exist() {
    local process_name="$1"
    local result=0

    if [ `ps aux | grep "$process_name" | wc -l` -gt 1 ]; then
        result=1
    else
        result=0
    fi
    echo $result
}

# Open vSwitch
export PATH=/usr/local/bin:/usr/local/java/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:$PATH

function ovs_vsctl() {
    local OVS_VSCTL_CMD="env PATH=$PATH ovs-vsctl"
    sudo timeout --signal=KILL 5s $OVS_VSCTL_CMD "$@"
}

function ovs_ofctl() {
    local OVS_OFCTL_CMD="env PATH=$PATH ovs-ofctl"
    sudo timeout --signal=KILL 5s $OVS_OFCTL_CMD "$@"
}

function ovs_appctl() {
    local OVS_APPCTL_CMD="env PATH=$PATH ovs-appctl"
    sudo timeout --signal=KILL 5s $OVS_APPCTL_CMD "$@"
}

function ovs_dpctl() {
    local OVS_DPCTL_CMD="env PATH=$PATH ovs-dpctl"
    sudo timeout --signal=KILL 5s $OVS_DPCTL_CMD "$@"
}

function ovs_list_br() {
    ovs_vsctl list-br
}

function ovs_list_ports() {
    local BRIDGE=$1
    ovs_vsctl list-ports $BRIDGE
}

function ovs_find_br_with_port() {
    local PORT=$1
    ovs_vsctl port-to-br $PORT 2> /dev/null
}

function is_ovs_port_in_br() {
    local PORT=$1
    local BRIDGE=$2
    ovs_ofctl show $BRIDGE | grep -q $PORT
}

function ovs_main_br_exists() {
    ovs_list_br | grep -q '^br_t$'
}

function ovs_fdb_show() {
    local BRIDGE=$1
    ovs_appctl fdb/show $BRIDGE 2> /dev/null
}

function ovs_of_dumpflows_with_br() {
    local BRIDGE=$1
    cmd_cache_global ovs_ofctl dump-flows $BRIDGE 2> /dev/null
}

function ovs_dp_dumpflows_with_br() {
    local BRIDGE=$1
    cmd_cache_global ovs_appctl dpif/dump-flows $BRIDGE
}

function ovs_dp_dumpflows_all() {
    if is_ovs_dpdk_running; then
        cmd_cache_global ovs_appctl dpctl/dump-flows
    else
        cmd_cache_global ovs_dpctl dump-flows
    fi
}

function ovs_dp_ports() {
    ovs_appctl dpif/show
}

function is_ovs_dpdk_running() {
    pgrep -f 'ovs-vswitchd .*--dpdk' > /dev/null 2>&1
}

# NOTE:
#
# 1. empty result is not cached
# 2. no cache invalidation or flush at the moment
# 3. don't cache too big output
# 3. don't run this in subprocess if the cache is to be used in parent
#
function cmd_cache_local() {
	local cache_var="$1"; shift
	local cache_val

	if [ "${cache_var#__cache_}" = "$cache_var" ]; then
		__errmsg "cache var needs to start with __cache_: $cache_var"
		return 1
	fi
	cache_var="${cache_var//-/_}"

	eval cache_val='"$'"$cache_var"'"'
	if [ -z "$cache_val" ]; then
		eval "export $cache_var="'$('"$@"')'
		eval cache_val='"$'"$cache_var"'"'
	fi
}

# execute cmd and cache output to file
function cmd_cache_global() {
    local ts=$(date -u +%s)
    local expire=10
    local cache_dir='/tmp/'
    local cache_file=''
    local cache_pattern=$(echo "$@" | tr '/[:blank:]' '_')

    mkdir -p $cache_dir
    (
        flock -x 17211
        for file in $(find $cache_dir -maxdepth 1 -name "$cache_pattern*" | sort); do
            cache_ts=$(echo $file | awk -F- '{print $NF}')
            if [ $(($ts - $cache_ts)) -gt $expire ]; then
                rm -f $file
            else
                cache_file=$file
            fi
        done
        if [ -z $cache_file ]; then
            cache_file=$cache_dir$cache_pattern'-'$ts
            "$@" > $cache_file
        fi
        cat $cache_file
    ) 17211>$cache_dir$cache_pattern"lock"
}
